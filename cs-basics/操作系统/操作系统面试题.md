

## Linux 命令

### 查看文件

**问题1：**查看文件的命令有哪些？怎么根据文件的关键词进行筛选？

**答案解析：**

**(1) 查看文件的命令**

| 命令   | 说明                                              | 示例用法                  | 应用场景                                     |
| ------ | ------------------------------------------------- | ------------------------- | -------------------------------------------- |
| `cat`  | 查看小型文件的内容，输出文件的全部内容。          | `cat filename`            | 查看小文件的内容，一次性显示整个文件的内容。 |
| `more` | 分页查看文件内容，适合长文件，按页显示。          | `more filename`           | 查看长文件时，可以按页显示，按空格键翻页。   |
| `less` | 类似 `more`，但提供更强大的滚动和搜索功能。       | `less filename`           | 查看长文件，支持向前向后滚动和搜索功能。     |
| `head` | 查看文件的前 N 行内容，默认 10 行。               | `head filename`           | 快速查看文件的开头部分。                     |
| `tail` | 查看文件的后 N 行内容，默认 10 行，支持实时更新。 | `tail filename`           | 查看文件的结尾部分或实时查看日志文件。       |
| `grep` | 查找文件中匹配正则表达式的行。                    | `grep 'pattern' filename` | 根据关键字或正则表达式筛选文件中的特定内容。 |

**（2）筛选指令**

比较常用的指令有 `grep`、`find`。

| 命令      | 说明                                     | 示例用法                                | 应用场景                                         |
| --------- | ---------------------------------------- | --------------------------------------- | ------------------------------------------------ |
| `grep`    | 查找文件中匹配特定模式的行。             | `grep 'pattern' filename`               | 筛选文件中包含特定字符串或正则模式的行。         |
| `grep -r` | 递归查找文件夹下所有文件中匹配的内容。   | `grep -r 'pattern' /path/to/directory/` | 在整个目录下递归查找某个关键词或正则表达式。     |
| `grep -v` | 反向筛选，显示不匹配的行。               | `grep -v 'pattern' filename`            | 用于排除匹配特定模式的行，显示不包含该模式的行。 |
| `grep -l` | 显示匹配模式的文件名而非内容。           | `grep -l 'pattern' *`                   | 查找包含指定模式的文件名，而不显示匹配的内容。   |
| `grep -i` | 忽略大小写进行搜索。                     | `grep -i 'Pattern' filename`            | 用于不区分大小写地搜索文件内容。                 |
| `sed`     | 使用正则表达式对文件内容进行筛选或替换。 | `sed '/pattern/d' filename`             | 删除包含某个模式的行，或替换匹配的内容。         |
| `awk`     | 基于列的内容进行筛选和处理。             | `awk '$1 == "value"' filename`          | 基于文件中某列的内容筛选数据。                   |
| `find`    | 在目录中查找符合条件的文件。             | `find /path/to/directory -name '*.txt'` | 查找目录中符合条件的文件。                       |



### 权限控制

**问题描述：**在Linux 系统里面，怎么控制文件权限？

**答案解析：**

**(1) chomd 数字的含义**

权限是通过将读、写和执行权限的数字值相加来计算的。具体来说：

- **读权限 (r)** 对应数字 `4`
- **写权限 (w)** 对应数字 `2`
- **执行权限 (x)** 对应数字 `1`

对于每个用户类别（文件所有者、所属组、其他用户），你可以通过加和来设置他们的权限。例如：

1. **所有者 (Owner)**: 第一位数字
2. **所属组 (Group)**: 第二位数字
3. **其他用户 (Others)**: 第三位数字

每一位数字代表的是权限的加和值，具体如下：

- `0` 表示没有任何权限
- `1` 表示仅执行权限 (`x`)
- `2` 表示仅写权限 (`w`)
- `3` 表示写权限和执行权限 (`wx`)
- `4` 表示仅读权限 (`r`)
- `5` 表示读权限和执行权限 (`rx`)
- `6` 表示读权限和写权限 (`rw`)
- `7` 表示读、写和执行权限 (`rwx`)

**（2） chmod 644 filename 的含义**

**`chmod 644 filename`**

- **6**: 所有者 (Owner) 具有读和写权限 (`rw`)
- **4**: 所属组 (Group) 具有读权限 (`r`)
- **4**: 其他用户 (Others) 具有读权限 (`r`)



### 软件安装

**问题描述：**在Linux 系统里面，怎么安装软件？软件安装的命令有哪些？

**答案解析：**

(1) 安装命令

Ubuntu、Debian、Linux Mint 等基于 Debian 的发行版使用 **APT（Advanced Package Tool）** 作为包管理工具。

```
sudo apt update         # 更新软件包列表
sudo apt install <软件包名称>.deb  # 安装指定软件包
```

RedHat、CentOS、Fedora 等基于 RPM 的发行版使用 **YUM（Yellowdog Updater, Modified）** 或 **DNF（Dandified Yum）**（Fedora 和 CentOS 8 之后的版本）作为包管理工具。

```
sudo yum install <软件包名称>    # 使用 yum 安装软件
sudo dnf install <软件包名称>    # 使用 dnf 安装软件（Fedora 和 CentOS 8 之后）
```



### 解压缩命令

**问题描述：**在Linux 系统里面，解压缩命令有哪些？解压缩后面的参数有哪些？

**答案解析：**

**(1) tar 命令**

`tar` 是用于打包和压缩文件的工具，它也支持解压缩。`tar` 可以处理 `.tar`、`.tar.gz`、`.tgz`、`.tar.bz2`、`.tar.xz` 等格式。

常用参数：

- `-x`：解包（解压缩）。
- `-f`：指定文件。
- `-z`：通过 `gzip` 解压（适用于 `.gz` 后缀）。
- `-j`：通过 `bzip2` 解压（适用于 `.bz2` 后缀）。
- `-J`：通过 `xz` 解压（适用于 `.xz` 后缀）。
- `-v`：显示解压缩过程中的文件列表（verbose模式）。
- `-C`：指定解压缩到的目标目录。

举个例子，

```shell
tar -xzvf file.tar.gz
```

**(2) unzip 命令**

`unzip` 用于解压 `.zip` 格式的文件。

常用参数：

- `-d`：指定解压到的目录。
- `-l`：列出 `.zip` 文件中的内容，但不解压。

举个例子，

```shell
unzip file.zip
```



## 基本概念

### 介绍一下操作系统



## 网络管理

### 网卡与网络接口

网卡，通常指的是计算机**硬件**中的一个组件，是计算机与网络之间的物理连接媒介。它负责通过电缆或无线电信号与网络（例如局域网、互联网等）进行通信。

网络接口是一个操作系统层面的**抽象概念**，指的是操作系统对网络连接的管理接口。每个网络接口通常会有一个对应的网络设备（如网卡）。操作系统通过网络接口来配置和管理网络通信。

| **概念**     | **网卡（NIC）**                                    | **网络接口**                                                |
| ------------ | -------------------------------------------------- | ----------------------------------------------------------- |
| **类型**     | 物理硬件设备                                       | 操作系统中的虚拟或逻辑接口                                  |
| **功能**     | 负责计算机与网络的物理连接                         | 负责在操作系统中管理网络通信、IP 配置、路由等               |
| **示例**     | 以太网卡、Wi-Fi 卡                                 | `eth0`（以太网接口）、`wlan0`（无线接口）、`lo`（回环接口） |
| **配置**     | 配置网卡驱动和硬件设备设置                         | 配置 IP 地址、子网掩码、路由等                              |
| **使用**     | 网卡用于物理设备连接，网络接口用于逻辑配置         | 网络接口用于操作系统的网络通信管理                          |
| **存在形式** | 硬件设备，通常是计算机主板上的一部分，或是插卡形式 | 操作系统中表示网络连接的虚拟或逻辑接口                      |



### 网络配置

- `ip` 命令是用于管理 Linux 网络的现代工具，它替代了旧的 `ipconfig` 命令

- `ping` 是最常用的诊断工具，用于检查网络连接性。

- `netstat` 是一个网络状态查看工具，用于显示当前系统的网络连接、路由表、接口统计信息等。



## 内存管理

### 文件

**(1) 文件的组成结构**

在 Linux 文件系统中，**inode** 和 **数据块**（Data Block）是两个非常重要的概念，它们共同作用于文件的存储和管理。

**inode** 是 Linux 文件系统中用于存储文件元数据的数据结构。每个文件在文件系统中都有一个对应的 inode，这个 **inode 是唯一的**。它不包含文件的内容，而是包含文件的关键信息：

- **文件类型**：普通文件、目录、符号链接等。
- **文件权限**：读、写、执行权限。
- **所有者**：文件的用户和组。
- **文件大小**：文件的字节数。
- **时间戳**：文件的创建时间、最后访问时间和最后修改时间。
- <font color="red">**硬链接计数**</font>：指向该 inode 的硬链接数量。
- **指向数据块的指针**：inode 通过这些指针将文件的内容映射到磁盘上的实际数据块。

**数据块** 是文件系统中存储实际文件内容的单位。数据块是磁盘或存储设备上的物理存储块，它保存了文件的内容（如文本、图片、视频等）。



### 文件描述符和文件句柄

**(1) 文件描述符**

**文件描述符**是操作系统内核为进程提供的一个非负整数，用于标识一个已打开的文件或其他 I/O 资源（如管道、套接字等）。文件描述符是进程与操作系统之间的接口，<font color="red">**进程通过文件描述符来操作文件**</font>。

常见的文件描述符有：

- `0`：标准输入（stdin）
- `1`：标准输出（stdout）
- `2`：标准错误（stderr）

这些文件描述符是预先打开的，用于与终端交互。

在 C 语言中，可以通过 `open()` 函数打开文件，并通过返回的文件描述符来进行后续的读写操作：

```c、
// fd 就是返回的文件描述符
int fd = open("example.txt", O_RDONLY);
if (fd == -1) {
    // 错误处理
}
```

**(2) 文件句柄 (File Handle)**

**文件句柄**通常是更高层次的概念，封装了文件描述符、文件相关的额外信息和常见的文件操作，特别是在编程语言和库的上下文中。

- 文件句柄<font color="red">**封装了对文件的所有操作**</font>，包括读写、文件位置指针、缓冲区等，它使得开发者能够以更为抽象和友好的方式操作文件。

- 文件句柄通常与具体的操作系统调用（如 `open`、`read`、`write`）紧密结合，但它**不直接暴露文件描述符**，而是提供了文件的高级接口。

在 C 语言中，`FILE*` 是一个文件句柄类型，通常通过 `fopen()` 函数来获取：

```
FILE* file = fopen("example.txt", "r");
if (file == NULL) {
    // 错误处理
}
```

**(3) 文件描述符和文件句柄的关系**

- 在低级别的操作系统接口中，文件描述符直接表示文件，而文件句柄是对文件描述符的封装，提供更多的操作功能和信息。

- 在常用的高级语言中，**文件操作通常通过文件句柄（而非直接使用文件描述符）来完成。操作系统在背后通过文件描述符与内核交互，完成实际的 I/O 操作**。



### 文件系统类型

- **NTFS (New Technology File System)**： Windows 操作系统的默认文件系统，支持文件权限、安全性、加密、压缩等高级功能。

- **ext4**：当前 Linux 系统中最常用的文件系统。它相较于 ext3 提供了更大的文件支持、更好的性能和更多的功能（如更大的文件系统、更高的文件数、日志功能等）



### 文件系统兼容

Linux 系统可以访问文件系统类型为 **NTFS** 的 U 盘，但需要通过额外的驱动程序和工具来实现。



### 文件系统挂载和自动挂载

**(1) 基本概念**

- **文件系统**：文件系统是操作系统用来管理存储设备上数据的结构和方法。它规定了数据如何存储、访问和管理。常见的文件系统类型有 `ext4`、`ntfs`、`vfat`、`xfs` 等。
- **挂载点**：挂载点是文件系统的“入口”，它是一个目录，挂载后的文件系统会在这个目录下显现。比如，你可以将一个 USB 驱动器挂载到 `/mnt/usb` 目录下。**挂载点本质上是一个路径**。
- **挂载**：挂载就是<font color="red">**将存储设备中的文件系统附加到现有的目录结构中的一个过程**</font>。操作系统会将存储设备的通过挂载，文件系统与指定的挂载点关联起来，从而能够访问存储设备上的文件和目录。

**(2) 文件系统挂载**

在类 Unix 操作系统中，**文件系统挂载（mount）**是指将一个存储设备（如硬盘、USB 驱动器、网络共享、CD/DVD 等）上的文件系统连接到系统的目录结构中，使得操作系统能够访问该存储设备上的文件。

**(3) 自动挂载** 

对于某些设备（如 USB 驱动器、硬盘等），系统在启动时会自动挂载。通常这些设备的挂载信息保存在 `/etc/fstab` 文件中。

**`/etc/fstab` 文件**：它是一个静态配置文件，其中记录了系统启动时应挂载的文件系统的信息，包括设备文件、挂载点、文件系统类型、挂载选项等。



### 链接

**问题描述：**软链接和硬链接有什么区别？

**答案解析:** 

**(1) 文件的组成结构**

在 Linux 文件系统中，**inode** 和 **数据块**（Data Block）是两个非常重要的概念，它们共同作用于文件的存储和管理。

**inode** 是 Linux 文件系统中用于存储文件元数据的数据结构。每个文件在文件系统中都有一个对应的 inode，这个 **inode 是唯一的**。它不包含文件的内容，而是包含文件的关键信息：

- **文件类型**：普通文件、目录、符号链接等。
- **文件权限**：读、写、执行权限。
- **所有者**：文件的用户和组。
- **文件大小**：文件的字节数。
- **时间戳**：文件的创建时间、最后访问时间和最后修改时间。
- <font color="red">**硬链接计数**</font>：指向该 inode 的硬链接数量。
- **指向数据块的指针**：inode 通过这些指针将文件的内容映射到磁盘上的实际数据块。

**数据块** 是文件系统中存储实际文件内容的单位。数据块是磁盘或存储设备上的物理存储块，它保存了文件的内容（如文本、图片、视频等）。

**(2) 硬链接和软链接的区别**

**硬链接** 是指向文件数据块的直接引用，它们共享相同的 inode，删除原文件不影响其他硬链接。

**软链接** 是一个指向文件路径的快捷方式，可以跨文件系统，但如果目标文件删除或移动，软链接会失效。

具体区别如下：

| 特性               | 硬链接 (Hard Link)                                 | 软链接 (Symbolic Link)                             |
| ------------------ | -------------------------------------------------- | -------------------------------------------------- |
| **指向对象**       | 指向文件的物理数据块（即 inode）                   | 指向文件路径（即文件名）                           |
| **跨文件系统**     | 不支持，必须在同一个文件系统中                     | 支持，可以跨文件系统创建链接                       |
| **目标文件删除后** | 如果源文件被删除，硬链接仍然有效，文件数据不会丢失 | 如果目标文件被删除，软链接会失效，变成“悬挂”链接   |
| **链接类型**       | 硬链接是文件的另一种名字，文件内容与原文件完全相同 | 软链接是指向原文件的路径，类似于快捷方式           |
| **对目录的支持**   | 不允许硬链接指向目录（避免文件系统结构混乱）       | 允许软链接指向目录                                 |
| **占用空间**       | 不占用额外的磁盘空间，仅增加一个目录项（文件名）   | 占用少量空间，仅保存指向目标路径的字符             |
| **文件删除后表现** | 只有最后一个硬链接被删除时，文件数据才会被删除     | 软链接删除后不会影响原文件，原文件删除后软链接无效 |
| **创建方式**       | 使用 `ln` 命令不带 `-s` 参数                       | 使用 `ln -s` 命令创建软链接                        |
| **可读性**         | 难以识别是否为硬链接，和原文件无区别               | 可以识别为软链接，通常显示为带有箭头的路径         |
| **适用场景**       | 用于在同一文件系统内创建文件的多个引用             | 用于创建快捷方式，跨文件系统链接或链接目录         |

**（3）硬链接只是文件名**

创建硬链接是在文件系统中创建一个指向目标文件的硬链接，硬链接与目标文件共享相同的 inode 和数据块，它们在文件系统中被视为同一实体，即使使用不同的文件名。**硬链接就相当于给文件起别名**。

文件名的作用：操作系统会比对某个目录项中的文件名与待查找文件的文件名是否匹配。如果匹配成功，则找到了目标文件的 inode 号码。根据 inode 号码，操作系统会通过 inode 表或其他[数据结构](https://edu.csdn.net/course/detail/40020?utm_source=glcblog&spm=1001.2101.3001.7020)获取与该 inode 相关联的元数据信息，如文件大小、权限、所有者等。一旦获取了 inode 信息，操作系统就知道了文件实际存储在哪些数据块中。通过 inode 中的指针或引用，操作系统可以定位到文件的数据块。



### 为什么要有虚拟内存

为了在多进程环境下，使得进程之间的内存地址不受影响，相互隔离，于是操作系统就为每个进程独立分配一套**虚拟地址空间**，每个程序只关心自己的虚拟地址就可以



## 进程

### 进程通信

| **通信方式**                 | **描述**                                                     | **特点**                           | **缺点**                             |
| ---------------------------- | ------------------------------------------------------------ | ---------------------------------- | ------------------------------------ |
| **管道 (Pipe)**              | 半双工通信，允许一个进程的输出作为另一个进程的输入，仅用于父子进程之间 | 简单的同步机制，FIFO方式           | 只能用于父子进程，单向通信           |
| **命名管道 (FIFO)**          | 同样是半双工通信，具备名字，可以在任意进程间使用             | 可以在非亲缘进程之间通信           | 单向通信                             |
| **消息队列 (Message Queue)** | 以消息为单位进行通信                                         | 支持消息优先级，灵活               | 队列大小有限，复杂度较高             |
| **共享内存 (Shared Memory)** | 多个进程可以访问同一块内存区域进行数据交换                   | 通信速度快，无需数据拷贝           | 需要额外同步机制，可能有数据竞争     |
| **信号量 (Semaphore)**       | 用于进程同步，控制对共享资源的访问                           | 适合同步，多进程对共享资源访问控制 | 不适合数据传输，主要用于同步控制     |
| **信号 (Signal)**            | 异步通信机制，用于通知事件发生                               | 适用于进程间的事件通知             | 只能传递有限的信息，无法传输复杂数据 |
| **套接字 (Socket)**          | 双向通信，支持本地和网络间的进程通信                         | 支持跨网络通信，灵活               | 需要处理网络协议，通信复杂度较高     |



### 进程是如何在操作系统中运行的

进程是操作系统中的基本执行单位，它是程序在计算机中执行的实例。

- 进程创建
- 进程状态
- 进程调度
- 进程同步与通信



### 进程写文件时崩溃，已写入的数据会丢失吗

**答案**：不会

**答案解析**：进程在执行 write 系统调用的时候，文件数据实际上写入到了内核的 page cache。因此，即使进程崩溃了，page cache 中的数据依旧能够持久化到硬盘中



### 进程运行中CPU所做的工作

进程在操作系统中运行时，CPU 主要通过以下步骤完成工作：

1. **取指**：从内存中获取指令。
2. **译码**：对指令进行解码，确定执行内容。
3. **执行**：执行指令中的操作，如算术运算、数据移动等。
4. **内存访问**：如果指令需要访问内存，读取或写入数据。
5. **写回**：将计算结果写回寄存器或内存。



### 什么原因导致 I/O 阻塞

I/O 阻塞通常发生在同步 I/O 模型中，它是因为 I/O 操作需要等待外部资源（如磁盘、网络、数据库等）完成工作，从而导致当前线程或进程无法继续执行其他任务。