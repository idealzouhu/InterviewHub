### 抽象类和接口的区别

**抽象类**：适用于有共同行为和状态的类之间的关系，可以**提供部分实现**，通常用于构建类的模板或基础功能。（通常会采用 模板模式来设计，例如 AQS）

**接口**：适用于**无关类之间共享某些行为**，可以支持多重实现，通常用于行为契约或功能扩展。



### 内部类

匿名内部类必须继承一个父类或者实现一个接口

匿名内部类中的方法不能是抽象的

匿名内部类不能定义任何静态成员和方法





### 访问修饰符

![1](images/011a24a9670c6e84c89cf8f4fb99dd25.jpeg)



当变量和方法前面没有修饰符，默认为包私有，即 default。



### 关键字

final



### static

在Java中，关键字 `static` 可以用来修饰内部类，从而创建静态内部类。

静态内部类与非静态内部类的区别在于，静态内部类不会持有外部类的引用。这使得**静态内部类可以在没有外部类实例的情况下被实例化**，并且可以直接访问外部类的静态成员变量和方法。





### 构造方法

在执行子类的构造方法时，会调用父类的构造方法。Java 中的构造方法有一个默认的行为是，在子类构造方法的第一行，调用父类的构造方法。

- **隐式调用**：如果子类的构造方法没有显式调用父类的构造方法，Java 会自动插入一个 `super()` 调用，前提是父类有无参构造方法。
- **显式调用**：如果父类只有带参构造方法，子类构造方法必须显式调用父类的构造方法，语法为 `super(参数)`，并且必须在子类构造方法的第一行。





### abstract

（1）抽象类

由于抽象类不能实例化对象，所以**抽象类必须被继承，才能被使用**。

抽象类除了不能实例化对象之外，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。

- 抽象类中**不一定包含抽象方法**，但是有抽象方法的类必定是抽象类。

- 类中如果有一个或多个abstract方法，则该类**必须声明为 abstract**；





（2）抽象方法

抽象方法只包含一个方法名，而没有方法体。

声明抽象方法会造成以下两个结果：

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。



(3) 不能声明为抽象方法的方法

构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

构造方法和类方法（即用 `static` 修饰的方法）不能声明为抽象方法的原因在于抽象方法的定义和用途与它们的特性不兼容。

1. 构造方法是用来创建对象的特殊方法，它在对象被实例化时被调用，用于初始化对象的状态。而抽象方法是没有方法体的方法，它需要在子类中被具体实现。因此，如果构造方法被声明为抽象方法，那么就无法实现它的具体功能，从而无法创建对象，违背了构造方法的初衷。
2. 类方法是属于类的方法，它们可以直接通过类名调用，而不需要创建类的实例。抽象方法需要在具体的子类中被实现，但类方法不依赖于任何对象的状态，所以它们不应该被声明为抽象方法，因为抽象方法是需要被实例化的。



**abstract class和interface有什么区别?**

答案：一个类只能继承一个抽象类，但却可以实现多个接口。抽象类中可以有也可以没有抽象方法。并且可以定义和常规类一样的变量和方法。而接口中所有的方法都是抽象的，所有的变量都是静态不可修改的。





## 相等

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。



- 对象的相等一般比较的是内存中存放的内容是否相等。  **equals()**
- 引用相等一般比较的是他们指向的内存地址是否相等。  **==**

```
// 使用 == 比较字符串的引用相等
System.out.println(str1 == str2);
System.out.println(str1 == str3);
// 使用 equals 方法比较字符串的相等
System.out.println(str1.equals(str2));
System.out.println(str1.equals(str3));
```



[Java基础常见面试题总结(中) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-02.html#为什么重写-equals-时必须重写-hashcode-方法)

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。





**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

```
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```





## 拷贝

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，**如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址**，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。
- **引用拷贝**：两个不同的引用指向同一个对象。

![浅拷贝、深拷贝、引用拷贝示意图](images/shallow&deep-copy.png)



## 面向对象

**编译时多态**： 方法重载是指在同一个类中，可以定义多个同名但参数列表不同的方法。

**运行时多态**：方法重写是指子类提供对父类方法的具体实现。重写的方法必须与被重写的方法具有相同的方法名、参数列表和返回类型。





## try-catch-finally 的使用

[Java基础常见面试题总结(下) | JavaGuide](https://javaguide.cn/java/basis/java-basic-questions-03.html#try-catch-finally-如何使用)

- `try`块：用于捕获异常。其后可接零个或多个 `catch` 块，**如果没有 `catch` 块，则必须跟一个 `finally` 块。**

- `catch`块：用于处理 try 捕获到的异常。

- `finally` 块：无论是否捕获或处理异常，`finally` 块里的语句都会被执行。**当在 `try` 块或 `catch` 块中遇到 `return` 语句时，`finally` 语句块将在方法返回之前被执行。**

**注意：不要在 finally 语句块中使用 return!** 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。



在某些情况下，finally 中的代码不会被执行。

- 程序所在的线程死亡。
- 关闭 CPU





## 子类

假设类A里面有类B，类A 存在方法 method1， 那类B里面的method 方法有什么限制？





## 集合

集合里面可以添加 null 值吗？