## 编译器

### 未定义行为

(1) 下列 C 代码中，不属于未定义行为的有：______。

A、`int i=0; i=(i++);`

B、`char *p="hello"; p[1]='E';`

C、`char *p="hello"; char ch=*p++;`

D、`int i=0; printf("%d %d\n",i++,i--);`

E、都是未定义行为

**正确答案：** C

**答案解析：**

- 未定义行为（Undefined Behavior）是指C语言标准未做规定的行为，导致运行结果不确定。常见现象有：
  - 变量即是左边结果，又是右边的操作数，如`a+=a++`，`a %= b ^= a ^= b ^= a`
  - 使用越界数组也是C的一个“未定义行为”
  - 允许一个随便指的指针的读写。
  - 使用未初始化的变量

- 关于 A 选项，**变量即是左边结果，又是右边的操作数**
- 关于 B 选项，`p` 指向字符串字面量  "hello"。在 C 中，**字符串字面量通常存储在只读存储区**，因此 `"hello"` 的内容是不可修改的。
- 关于 D 选项，C 语言标准规定，**在一个表达式中对同一变量进行多次修改且没有明确的顺序点时，行为是未定义的**。也就是说，`i++` 和 `i--` 的求值顺序是不确定的，结果无法预测。







### 内存分配

### 堆栈

（1） 堆的常考知识点

- 对于堆，大量的 new/delete 操作会造成内存空间的不连续。
- 堆容易产生 memory leak。

- **堆的效率比栈要低得多**。每次压栈和弹栈的操作都非常简单，只需要调整栈指针。栈内存是连续分配的，分配和释放内存的过程基本上是常数时间操作（O(1)）。堆内存的分配和释放通常是由操作系统（或运行时库）管理的。内存的分配和回收是动态的，堆需要维护一个空闲内存块的列表，分配和释放内存的时间可能不是常数时间操作。

(2) 栈的常考知识点

- **栈变量引用容易逃逸**。当栈变量的地址或引用被返回或传递到栈外时（比如作为指针传递到栈外，或者作为返回值传递到栈外），就会发生栈变量的逃逸。由于栈上数据在函数返回后会被销毁，所以如果我们在栈外引用这个数据，可能会导致指针悬空（dangling pointer）或者访问到无效内存。







(1）常见判断题

- 对于栈来讲，生长方向是向上的，也就是向着内存地址增加的方向  ❌

  **答案解析：**

  - **“栈的生长方向是向下的“。**栈的空间分配是从内存的**高地址**开始，并随着数据的压入，栈指针（栈顶指针）逐渐向**低地址**移动。假设内存中栈的起始位置是 `0x1000`，栈向低地址生长，即栈顶指针从 `0x1000` 向 `0x0000` 移动。
  - **“堆的生长方向是向上的“**。堆的内存空间通常从低地址开始分配，并随着数据的增加，堆指针（指向堆顶的指针）向高地址移动。
  - 为什么堆和栈的方向相反？ 在大多数系统中，栈和堆是共享同一块内存区域的，而它们的生长方向是相反的。栈从高地址开始向低地址扩展，堆从低地址开始向高地址扩展。这样的设计使得栈和堆可以在有限的内存空间内高效地共享，并且最大化地利用空间。

- 堆的效率比栈要低得多   ✅

- 栈区一般由编译器自动分配释放，堆区一般由程序员分配释放。 ✅